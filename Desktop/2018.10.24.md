





​                                                                                    泛型

泛型的作用是提高程序的复用性。与多态不同的是，应用泛型可以减少数据的数据转换，从而提高代码的运行效率。泛型实际上是通过给类或接口增加类型参数。

不带泛型的类格式：[类修饰词列表]  class  类名  [extends 父类名]  [implements 接口名称列表] ｛ 类体 ｝

具有泛型特点的类定义格式： 类名<类型参数> 或 类名<类型参数1，类型参数2……>

不带泛型的接口格式： [接口修饰词列表]  interface  接口名 [extends 接口名称列表] ｛

接口体 ｝

具有泛型特点的接口定义格式： 接口名<参数列表1> 或 接口名 <参数列表1，参数列表2…>

类型参数的定义格式：（1）类型变量标识符

​                   （2）类型变量标识符  extends  父类型

​                   （3）类型变量标识符  extends 父类型1&父类型2

注：第一种和第二种实际上是一样的。

第二种定义形式：表明所定义的类型变量是其父类型的子类型。如：父类的子类或实现接口的类

第三种定义形式：表明所定义的类型变量具有在格式中所规定的各个父类型的所有能力。它要求在各个父类型中最多只能有一个为类，即其余类型均为接口。

 

​                                 枚举

枚举的基本定义格式：

[枚举类型修饰词列表]  enum  枚举类型标识符

｛  枚举常量1， 枚举常量2，  枚举常量3…….  ｝

例： enum SEASON

{

​      春季，夏季，秋季，冬季

｝

枚举变量的定义格式：

​        枚举类型标识符  枚举变量；

​        枚举类型标识符   枚举变量1， 枚举变量2，……. 枚举变量n；

枚举数组变量定义格式： 

​        SEASON  []  s;

对于枚举类型，不能使用new运算符创建实例对象。可以直接通过枚举类型标识符访问枚举常量。

​     SEASON  s  =  SEASON.春季；

对于枚举常量，它有些类似于类的静态成员域，即可以通过枚举变量访问枚举常量。

例如：s.夏季  ==  SEASON.夏季

通过枚举类型，可以通过调用成员方法values获得该枚举类型的所有枚举变量，其调用格式：

  枚举类型标识符.values（）

例： SEASON  [ ]  sa  =  SEASON.values（）;

 

​             For语句的简化写法

格式：for （类型  标识符  ：  表达式）

​      语句或语句块

第一种for语句的简写方法：

​     For（Iterator <类型>  i=表达式.iterator（）；i.hasNext（）；）

​            ｛

​             类型  标识符  =  i.next（）；

​              语句或语句块

｝

 

  第二种for语句的简写方法：

​       类型 [  ]  ca  = 表达式；

For （ int i = 0; i<ca.length; i++ ）

｛

   类型  标识符 = ca[i];

   语句或语句块

｝