​                                                                 JAVA编写风格

1.          命名

(1)类名，接口名采用驼峰方法，每个单词的首字母大写，其余小写。

(2)方法名，变量名，函数采用首单词小写的驼峰命名法。

(3)常量名 全部大写 单词之间用_隔

(4)包名 所有单词小写 单词之间用.隔

(5)名字的命名一眼看的懂，超过15个单词的用缩写。

2.           Import语句

(1)Import不使用*。

(2)每个import语句独立成行。

3.           大括号

(1)大括号与if，else，for，do，while语句一起使用，即使只有一条语句或为空，也(2)应该把大括号写上

(3)左大括号前不换行

(4)左大括号后换行

(5)右大括号前换行

(6)如果右大括号是一个语句、函数体或类的终止，则右大括号后换行；否则不换行。

4.           空块

(1)一个空的块状结构里什么也不包含，大括号可以简洁写成｛｝，不需要换行。例外(2)如果它是一个多块语句的一部分（if/else），即使大括号内没内容，右大括号也换行。

(3)每开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别

 (4)一行一语句。每个语句后要换行

5.      变量申明

 (1) 每次只声明一个变量，不要使用组合声明。

 (2) 需要使用时才申明，并尽快对它进行初始化赋值

6.      数组

 (1)数组初始化可写成块状结构

 7       switch

  (1)     Switch 块中的内容缩进为两个空格。每个switch标签后新起一行再缩写2个空格写下一条或多条语句。

8.       注释

(1)块注释与周围的代码在同一缩进级别。单行//  多行/*..*/

​                                                         JAVA基本运算方式

| **运算符** | **名称** | **描述**                 | **类型**   | **举例**             |
| ---------- | -------- | ------------------------ | ---------- | -------------------- |
| +          | 加法     | 相加运算符两侧的值       | 双目运算符 | a +   b 等于 8       |
| -          | 减法     | 左操作数减去右操作数     | 双目运算符 | a -   b 等于 2       |
| *          | 乘法     | 相乘操作符两侧的值       | 双目运算符 | a *   b 等于 15      |
| /          | 除法     | 左操作数除以右操作数     | 双目运算符 | a /   b 等于 1       |
| %          | 取余     | 左操作数除右操作数的余数 | 双目运算符 | a %   b 等于 2       |
| ++         | 自增     | 操作数的值增加1          | 单目运算符 | ++i（或i++）   等于2 |
| --         | 自减     | 操作数的值减少1          | 单目运算符 | --i（或i--）   等于0 |

 

| **位运算符** | **名称**     | **描述**                                                     | **举例**                       |
| ------------ | ------------ | ------------------------------------------------------------ | ------------------------------ |
| &            | 按位与       | 如果相对应位都是1，则结果为1，否则为0                        | （a＆b），得到1，即0000 0001   |
| 丨           | 按位或       | 如果相对应位都是0，则结果为0，否则为1                        | （a丨b）得到7，0000   0111     |
| ^            | 按位异或     | 如果相对应位值相同，则结果为0，否则为1                       | （a^b）得到6，即   0000   0110 |
| ~            | 按位补       | 翻转操作数的每一位，即0变成1，1变成0                         | （〜a）得到-6，即1111   1010   |
| <<           | 按位左移     | 左操作数按位左移右操作数指定的位数                           | a<<2得到20，即 0001   0100     |
| >>           | 按位右移     | 左操作数按位右移右操作数指定的位数                           | a>>2得到1即 0001               |
| >>>          | 按位右移补零 | 左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 | a>>>2得到1即0001               |

注：十进制的负数转化为二进制。首先将负数转换为对应的原码（正数的二进制），再将原码的每一位做取反操作得到反码。最后将反码+1得到补码

 

| **逻辑运算符** | **名称** | **描述**                                                     | **类型**   | **举例**         |
| -------------- | -------- | ------------------------------------------------------------ | ---------- | ---------------- |
| &&             | 与       | 当且仅当两个操作数都为真，条件才为真                         | 双目运算符 | （a && b）为假   |
| ｜｜           | 或       | 两个操作数任何一个为真，条件为真                             | 双目运算符 | （a ｜｜ b）为真 |
| ！             | 非       | 用来反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将得到假 | 单目运算符 | （!a）为假       |
| ^              | 异或     | 如果两个操作数逻辑相同，则结果为假，否则为真                 | 双目运算符 | （a ^ b）为真    |

注：&和&&在功能上是相似的。区别在于：单个"&",左边无论真假，右边都进行计算。
 &&,左边为假，右边不进行计算。|和||也是如此。

 

| **赋值运算符** | **名称** | **描述**                               | **类型**   | **举例**              |
| -------------- | -------- | -------------------------------------- | ---------- | --------------------- |
| =              | 赋值     | 右操作数的值赋给左侧操作数             | 双目运算符 | a = c                 |
| +=             | 加等于   | 左操作数和右操作数相加赋值给左操作数   | 双目运算符 | a += c等价于a = a + c |
| -=             | 减等于   | 左操作数和右操作数相减赋值给左操作数   | 双目运算符 | a -= c等价于a = a - c |
| *=             | 乘等于   | 左操作数和右操作数相乘赋值给左操作数   | 双目运算符 | a *= c等价于a = a * c |
| /=             | 除等于   | 左操作数和右操作数相除赋值给左操作数   | 双目运算符 | a /= c等价于a = a / c |
| %=             | 取余等于 | 左操作数和右操作数取模后赋值给左操作数 | 双目运算符 | a %= c等价于a = a % c |

 

| **比较运算符** | **名称** | **描述**                                                     | **举例**          |
| -------------- | -------- | ------------------------------------------------------------ | ----------------- |
| ==             | 等于     | 判断两个操作数的值是否相等，如果相等则条件为真               | （a == b）为false |
| ！=            | 不等于   | 判断两个操作数的值是否相等，如果值不相等则条件为真           | (a != b) 为true   |
| >              | 大于     | 判断左操作数的值是否大于右操作数的值，如果是那么条件为真     | （a > b）为false  |
| <              | 小于     | 判断左操作数的值是否小于右操作数的值，如果是那么条件为真     | （a < b）为true   |
| >=             | 大于等于 | 判断左操作数的值是否大于或等于右操作数的值，如果是那么条件为真 | （a >= b）为false |
| <=             | 小于等于 | 判断左操作数的值是否小于或等于右操作数的值，如果是那么条件为真 | （a <= b）为true  |

 

​                                                               IF语句

理解：一种判断语句。如果…..就…..。对每种可能性及其对应的结果进行阐述。运用分类、排查等情况，使代码更加严紧。



语法：（1）If（条件）｛ 条件成立时的代码块｝

​            （2）If（条件）｛代码块1｝  else｛代码块2｝

​             注：条件成立的时候执行代码块1，条件不成立的时候用代码块2。

​             （3）多重if语句，在条件1不满足的情况下执行判断条件2，直到执行else。

​             注：注意每种情况的阐述顺序，层次顺序、逻辑顺序不能乱。

​            （4）嵌套if语句。只有外面的if成立后才会判断嵌套if语句

​    注：（1）如果多重if语句是个金字塔，那么嵌套if语句就是洋葱。同样层次顺序、逻辑顺序                                  不能乱。

（2）注意每个if语句对应的结果。书写时，条件是由外向内写，结果是由内向外写。阅读时由内向外读，一层一层剥开。

注：（1）if条件语句书写的时候只能m>60.不能70>m>60。

（2）一般是在代码块1和代码块2处写出结果

​                                                              Switch语句

理解：一种判断语句。当…..则…..。根据表达式里面的内容在case里面找出对应的值。与if语句的意思是差不多的，只不过Swith语句比if语句跟简单明了，。主要是运用于类似抽奖这种情况。将可能的情况用1、2、3表示然后直接套出对应的值。



语法：Switch（表达式）｛

​              Case 值1；

​              代码块

​               Break;

​              Case 值2；

​                代码块

​               Break；

​               ………

​               Default

​              默认执行的代码块

｝

​                                                               While语句

理解：它不像if那样注重于判断。它注重于将一定范围内，将满足条件的情况通过循环的方式找出来统一处理。它的特点一个是循环，一个是判断范围。While注重于将一个范围内符合条件的筛选出来然后进行统一的操作，并不注重与判断。所以虽说while语句和if语句有些是可以转换的但是侧重点不同。



语法：While（条件）｛代码｝   

​      Do{代码块} while（条件）；

注： （1）while是先判断条件，条件成立才执行代码块。Do/while是先执行一次在判断条件。

（2）do/while 由于先要执行一次所以代码块处有时需要判断，就用if语句

（3）while和do/while的作用在于在一定条件下把多的简单重复的操作循环执行。

（4）while和do/while的输出语句一般都是在条件为假的时候输出。

（5）while和do/while条件判断和if一样是有单边性的。

​                                                             For循环语句

理解：for和while虽然都有循环的意思，但是有区别的。For的循环次数被最开始的三个要素就给决定了。while的循环次数是未知的，取决于判断语句和条件语句。有可能while语句一次也不循环，有可能它会循环很多很多次。                           

​      所以这就使得他们的功能和运用场景不太一样。For用于一定的模式构架，因为你知道它循环的结果是什么。它是固定的。While就不一样了，你不知道它循环的结果是什么。

​      双For有一个特点是每一次循环结束后都会返回最初值，这个是while做不到的。

​      感觉for语句就不太常和if语句同时运用，可能是因为for最开始的三个语句就有一定的限制范围的作用，同时for运行的结果事先也是知道的。



语法：For（循环变量初始化；循环条件；循环变量变化）｛循环操作｝

注： （1）循环变量初始化是设置循环的初始状态，只执行一次。

（2）循环条件执行如果是true则执行循环内部的代码如果是false则跳出循环。

（3）循环变量变化部分是改变变量的值一便下次循环。

（4）循环变量初始化这个部分只定义循环的变量。其他变量在之前就定义。所以循环变量只有一个。

​                                                      Continue和break

理解：break结束循环很直。只要它得到答案，满足条件了它就结束了，这个循环它就不做了。Continue不一样，它找到答案之后它只是不再这个循环中继续算，但它会找执行其他的循环。

​      所以呢，break和continue运用的场景是不太相同的。

定义：Continue的作用是跳过循环体中剩下的语句执行下一次循环

Break的作用是直接结束循环。

​                                                                       数组

理解：数组就像矩阵，目的是为了定位，把同一类的放在一起方便管理。更多的运用来创建一个格式。

数组和for一起用的时候比较多，因为for通过循环可以将数组铺开。建立一个模块



定义：用来存储固定大小的同类型元素。相同数据类型的元素按一定顺序排列的集合。

声明语法：数据类型[ ]  数组名； 或者  数据类型  数据名[ ]; 例： int ages[ ];

分配空间：数组名 = new 数据类型 [ 数组长度 ]； 申明数组最多可存放元素的个数。

一个数组赋值给另一个数组： int [] a1 = ｛1，2，3｝ int [ ] a2； a2=a1;

数组和FOR的结合： for（元素类型 元素变量： 遍历对象）｛ 执行代码 ｝

二维数组：数据类型 [ ][ ] 数组名 = new 数据类型[行的个数][列的个数]; 

数据类型 [ ][ ] 数组名; 数组名 = new 数据类型[行的个数][列的个数];

注： （1）格式：数组中第”+i+”个元素是： “ + age

​     （2）数组下标从0开始。下标范围是0至数组长度-1。

 

​                                                                   方法

理解：方法是一个很有用的一个结构。通过创建一个方法来解决一个问题，将解决这个问题的代码写出来。等以后遇到这种问题的时候就直接调用就好了，这样就很方便，不用重复的写代码。

问题解决好了之后就会得到一个答案。这个答案要反馈给主程序。返回值类型就是这个答案的类型。因此主程序需要有一行代码用来接受这个返回值。最后返回值=对象名.方法名（参数），这么一个结构来实现方法的调用。问题就得到解决。

​      在这里参数分为实参和形参。形参是写在参数列表中的，它只是一个形式没有具体的值。它的作用就在与方便书写方法体。实参是在调度方法的时候写的具体数据。这到了计算的时候了，所以一定要明确的写出来参数的值。

​      访问修饰符的意义在于表示访问这个方法的权限。

​      方法的重载也是很有意义的。比如说考试成绩求和。有理科总成绩，文科总成绩，总成绩。这三个都是sum。为了区分，就需要参数不同。这个就是方法重载的意义。这么就不重复。



作用：解决特定问题的代码组合。

语法：访问修饰符  返回值类型  方法名（参数列表）｛ 方法体 ｝

访问修饰符：代表方法允许被访问的权限范围。

返回值类型：方法返回值的类型。

方法名：方法的名字。

参数列表：是传递给方法的参数列表，参数可以有多个。

方法体：方法体包含具体的语句，定义该方法的功能。

调用实际参数值语法：对象名.方法名（参数1，参数2…..）

方法重载：在一个类中，有一系列的方法具有相同的方法名，但是参数列表不同。

方法的返回类型为void，则方法中不能使用return返回值。

注： （1）方法体放在一对大括号中，实现特定的操作

​     （2）调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应。

​     （3）调用方法时，实参不需要指定数据类型。

​     （4）当方法参数有多个时，多个参数间以逗号分隔。

​     （5）如果方法的返回类型为void，则方法中不能使用return返回值。

​     （6）方法的返回值最多只能有一个，不能返回多个值。

​     （7）方法返回值的类型必须兼容。

​        

​                                                           类和对象

理解：类是一个整体，对象使这个整体的一个个例。就像一个班是个类，一个同学就是一个对象。这也就为什么调用方法的格式是对象名.方法名。

​      构造方法它可以定义类的属性，比较方便。

 

定义：类是相同或相似对象的一个抽象，是对象的一个模版，它描述一类对象的行为和状态。

​     类是具有相同属性和方法（行为）的对象的集合。

属性：对象具有的特征。每个对象的每个属性都拥有特定值。

定义类三步骤。1.定义类名。2.编写类的属性。3.编写类的方法。

构造方法：在创建一个对象的时候，至少要调用一个构造方法。

​          People  XiaoMing  =  new  People(168, 21, 1);

注： （1）如果我们在定义类的时候没有写构造方法，系统会默认给我们生成一个无参构造方法，不过这个构造方法什么不会做。

​     （2）当有指定的构造方法时，系统都不会再为我们添加无参构造方法了。

创建对象语法： 类名  对象名  = new  类名（）；

​                                                                    封装

封装：将抽象性函数接口的实例细节部分包装、隐藏起来的方法。防止该类的代码和数据被外部类定义的代码随机访问。

优点：只能通过规定的方法访问数据，使代码更安全。

​      隐藏类的实例细节，方便修改和实现。

实现：1.修改属性的可见性，在属性的前面添加修饰符private。

​      2.对每个值属性提供对外的公共方法访问，如创建getter/setter方法，用于对私有属性的访问。

​       3．在getter/setter方法里加入属性的控制语句。

​                                                                   包

作用：1.把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。

​     2.包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同的包中相同的类时，应该加上包名加以区别。

​     3.包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

定义：package 包名 //注意：必须放在源程序的第一行，包名可用"."号隔开。例如 package com.shiyanlou.java

Import：在不同包中使用另一个文件中的类。例如： import com.shiyanlou.people.如果是import com.shiyanlou.*则是将包下的所有文件都导入进来。

 

this：this关键字代表当前对象。This.属性操作当前对象的属性，this.方法调用当前对象方法。

内部类作用：1.内部类提供更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。

​            2.内部类的方法可以直接访问外部类的所用数据，包括私有的数据。

​            3.内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。

​            4.内部类允许继承多个非接口类型

注：1.内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。

​    2.定义成员内部类后，必须使用外部类对象来创建内部类对象，即内部类 对象名 = 外部类对象.new 内部类（）；

静态内部类是 static 修饰的内部类

特点：（1）静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问

（2）如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员

（3）创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();

局部内部类：是指内部类定义在方法和作用域内。局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用后无法引用的。

 

匿名内部类：就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。

 